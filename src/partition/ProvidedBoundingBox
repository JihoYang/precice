#include "partition/ProvidedBoundingBox.hpp"
#include "com/CommunicateMesh.hpp"
#include "com/Communication.hpp"
#include "utils/MasterSlave.hpp"
#include "m2n/M2N.hpp"
#include "utils/EventTimings.hpp"
#include "mesh/Mesh.hpp"
#include "mapping/Mapping.hpp"
#include "mesh/Mesh.hpp"
#include "mesh/Vertex.hpp"
#include "mesh/Edge.hpp"
#include "mesh/Triangle.hpp"


using precice::utils::Event;

namespace precice {
namespace partition {

logging::Logger ProvidedBoundingBox:: _log ( "precice::partition::ProvidedBoundingBox" );

ProvidedBoundingBox::ProvidedBoundingBox
(mesh::PtrMesh mesh,
 bool hasToSend,
 double safetyFactor)
:
    Partition (mesh),
    _hasToSend(hasToSend),
    _bb(mesh->getDimensions(),std::make_pair(std::numeric_limits<double>::max(), std::numeric_limits<double>::lowest())),
    _dimensions(mesh->getDimensions()),
    _safetyFactor(safetyFactor)
{}

void ProvidedBoundingBox::communicate()
{

  if (_hasToSend) {

 
  
    Event e1("creat and gather bounding box");

    if (utils::MasterSlave::_slaveMode) {//slave
      prepareBoundingBox();
      com::CommunicateMesh(utils::MasterSlave::_communication).sendBoundingBox (_bb, 0); 
    }
    else{ // Master
      assertion(utils::MasterSlave::_rank==0);
      assertion(utils::MasterSlave::_size>1);
      
      mesh::Mesh::GlobalBoundingBox globalBB; 
      for (int rankSlave = 1; rankSlave < utils::MasterSlave::_size; rankSlave++) {
        com::CommunicateMesh(utils::MasterSlave::_communication).receiveBoundingBox(_bb, rankSlave); 

        DEBUG("From slave " << rankSlave << ", bounding mesh: " << _bb[0].first
                     << ", " << _bb[0].second << " and " << _bb[1].first << ", " << _bb[1].second);
        globalBB[rankSlave] = _bb;
        
      }

      // Now also creat Bounding Box around master vertices
      prepareBoundingBox();
      globalBB[0] = _bb;
     
    }
    e1.stop();

    Event e2("send global Bounding Box");
    if (not utils::MasterSlave::_slaveMode) {
      mesh::Mesh::GlobalBoundingBox globalBB; 
      com::CommunicateMesh(_m2n->getMasterCommunication()).sendBoundingBoxSet(globalBB,0); 
    }
    e2.stop();
  }  
}

void ProvidedBoundingBox::prepareBoundingBox(){

  _bb.resize(_dimensions, std::make_pair(std::numeric_limits<double>::max(), std::numeric_limits<double>::lowest()));

  //create BB around both "other" meshes
  if (_fromMapping.use_count()>0) {
    auto other_bb = _fromMapping->getOutputMesh()->getBoundingBox();
    for (int d=0; d < _dimensions; d++) {
      if (_bb[d].first > other_bb[d].first) _bb[d].first = other_bb[d].first;
      if (_bb[d].second < other_bb[d].second) _bb[d].second = other_bb[d].second;  //Amin @ 1.15 : is condition right?
    }
  }
  if (_toMapping.use_count()>0) {
    auto other_bb = _toMapping->getInputMesh()->getBoundingBox();
    for (int d=0; d<_dimensions; d++) {
      if (_bb[d].first > other_bb[d].first) _bb[d].first = other_bb[d].first;
      if (_bb[d].second < other_bb[d].second) _bb[d].second = other_bb[d].second; // here as well ^
    }
  }

  //enlarge BB
  assertion(_safetyFactor>=0.0);
  for (int d=0; d<_dimensions; d++) {
    if (_bb[d].second > _bb[d].first){
      double sideLength = _bb[d].second - _bb[d].first;
      _bb[d].second += _safetyFactor * sideLength;
      _bb[d].first -= _safetyFactor * sideLength;
    }
  }
}
}
}
